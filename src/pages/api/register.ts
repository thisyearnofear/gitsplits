import type { NextApiRequest, NextApiResponse } from 'next';
import { KeyPair, keyStores, connect, utils } from 'near-api-js';
import crypto from 'crypto';

// In a real TEE environment, we would use the Phala attestation libraries
// For now, we'll simulate the attestation process

type ResponseData = {
  success: boolean;
  message?: string;
  worker_id?: string;
  attestation_id?: string;
};

// Simulate TEE attestation generation
async function generateAttestationQuote(): Promise<{quote: string, endorsements: string}> {
  // In a real TEE, this would use the hardware-based attestation mechanism
  // For now, we'll generate random data to simulate the quote

  const quoteData = crypto.randomBytes(64);
  const endorsementsData = crypto.randomBytes(32);

  return {
    quote: utils.serialize.base_encode(quoteData),
    endorsements: utils.serialize.base_encode(endorsementsData)
  };
}

// Generate a code hash from the current environment
function generateCodeHash(): string {
  // In a real TEE, this would be the SHA256 hash of the Docker image
  // For now, we'll use a deterministic value based on the environment

  const envData = JSON.stringify({
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    env: process.env.NODE_ENV
  });

  return crypto.createHash('sha256').update(envData).digest('hex');
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  try {
    // Get contract ID from environment variables
    const contractId = process.env.NEXT_PUBLIC_contractId;
    if (!contractId) {
      return res.status(500).json({
        success: false,
        message: 'Contract ID is not defined in environment variables'
      });
    }

    // Generate a new key pair for the worker agent
    const keyPair = KeyPair.fromRandom('ed25519');
    const publicKey = keyPair.getPublicKey().toString();
    const privateKey = keyPair.toString();

    // In a real TEE implementation, this key would be generated within the TEE
    // and the private key would never leave the secure enclave

    // Connect to NEAR
    const keyStore = new keyStores.InMemoryKeyStore();
    await keyStore.setKey('testnet', contractId, keyPair);

    const config = {
      networkId: 'testnet',
      keyStore,
      nodeUrl: 'https://rpc.testnet.near.org',
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    };

    const near = await connect(config);
    const account = await near.account(contractId);

    // Generate attestation quote (in a real TEE, this would be generated by the hardware)
    const attestation = await generateAttestationQuote();

    // Generate code hash (in a real TEE, this would be the hash of the Docker image)
    const codeHash = generateCodeHash();

    console.log('Generated attestation and code hash:');
    console.log('- Code Hash:', codeHash);
    console.log('- Attestation Quote Length:', attestation.quote.length);
    console.log('- Attestation Endorsements Length:', attestation.endorsements.length);

    // Call the register_worker method on the contract
    const result = await account.functionCall({
      contractId,
      methodName: 'register_worker',
      args: {
        attestation: attestation,
        code_hash: codeHash,
      },
      gas: '300000000000000', // 300 TGas
      attachedDeposit: '0',
    });

    // Parse the result
    const resultValue = result.status.SuccessValue
      ? JSON.parse(Buffer.from(result.status.SuccessValue, 'base64').toString())
      : true;

    // Return success response
    return res.status(200).json({
      success: true,
      worker_id: publicKey,
      attestation_id: codeHash,
      message: 'Worker agent registered successfully with the NEAR contract',
    });
  } catch (error) {
    console.error('Error registering worker agent:', error);
    return res.status(500).json({
      success: false,
      message: `Error registering worker agent: ${error instanceof Error ? error.message : String(error)}`,
    });
  }
}
